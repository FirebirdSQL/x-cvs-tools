/*
 *
 *	PROGRAM:	SMM source maintainence manager utility routines
 *	MODULE:		stuff.e	
 *	DESCRIPTION:	a database application for managing source code	
 */
  
/*
 * The contents of this file are subject to the InterBase Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License.
 * 
 * You may obtain a copy of the License at http://www.Inprise.com/IPL.html.
 * 
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.  The Original Code was created by Inprise
 * Corporation and its predecessors.
 * 
 * Portions created by Inprise Corporation are Copyright (C) Inprise
 * Corporation. All Rights Reserved.
 * 
 * Contributor(s): ______________________________________.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../marion/marion.h"

#if (defined WIN_NT || defined OS2_ONLY)
#include <io.h>
#include <malloc.h>
#define GDS_ALLOC	malloc
#else
#define GDS_ALLOC	gds__alloc
#endif

DATABASE 
    SMM = EXTERN FILENAME "marion.gdb";

extern TEXT	pathname [];
extern TEXT	component [];
extern TEXT	log_name [];
extern TEXT	dbb_name [];
extern TEXT	user_name [];
extern TEXT	password [];
extern USHORT	quit;
extern USHORT	op_sys_code, log_info;

extern USHORT	verbose;
extern TEXT	share_since_date[];
extern TEXT	pathname[];
extern TEXT	component [];
extern USHORT	quit;
extern USHORT	smm_since;
extern USHORT	smm_version;
extern USHORT	doc_version;
extern SSHORT	headers;
extern USHORT	capabilities;

static TEXT	*vector [256];

typedef struct  {
    TEXT	*s_string;
    TEXT	*s_replacement;
} S; 

static S in_strings [] = {
    (TEXT *) "#include \"..",		(TEXT *) "#include \"source",	/* PC & WIN_NT */
    (TEXT *) "#include \"/source",	(TEXT *) "#include \"source",	/* VMS */
    (TEXT *) "#include <",		(TEXT *) "#include <",
    (TEXT *) "#include \"/isc_source",	(TEXT *) "#include \"isc_source",/* VMS */
    NULL,				NULL
    };

static S
    out_strings1 [] = {
	NULL,				NULL,				/* Undefined */
	(TEXT *) "#include \"source",	(TEXT *) "#include \"/source",	/* VMS */
	(TEXT *) "#include \"source",	(TEXT *) "#include \"..",	/* PC */
	(TEXT *) "#include \"source",	(TEXT *) "#include \"..",	/* WIN_NT */
	(TEXT *) "#include \"source",	NULL,				/* MPE/XL */
	NULL,				NULL,				/* UNIX */
	NULL,				NULL,				/* UNIX_NO_DOLLAR */
	},
    out_strings2 [] = {
	NULL,				NULL,				/* Undefined */
	(TEXT *) "#include \"isc_source",	(TEXT *) "#include \"/isc_source",	/* VMS */
	NULL,				NULL,				/* PC */
	NULL,				NULL,				/* WIN_NT */
	NULL,				NULL,				/* MPE/XL */
	NULL,				NULL,				/* UNIX */
	NULL,				NULL,				/* UNIX_NO_DOLLAR */
	};                              

typedef struct {
    TEXT	*os_name;
    USHORT	os_number;
} OS_TAB;
		
static OS_TAB opsys_table[] = {
    (TEXT *) "NONE",		0,
    (TEXT *) "VMS",		OS_VMS,
    (TEXT *) "PC",		OS_PC,
    (TEXT *) "WIN_NT",		OS_WIN_NT,
    (TEXT *) "MPE/XL",		OS_MPEXL,
    (TEXT *) "UNIX",		OS_UNIX,
    (TEXT *) "UNIX_NO_$",	OS_UNIX_NO_DOLLAR,
    NULL,	0
};

static TEXT *switches[] = {
    (TEXT *) "-A all...write out all modules in this component",
    (TEXT *) "-D database...override the default source/marion.gdb",
    (TEXT *) "-C component...force the use of this component",
    (TEXT *) "-H headers...force headers on all files",
    (TEXT *) "-O operating system...VMS, PC, WIN_NT, MPE/XL, UNIX, UNIX_NO_$",
    (TEXT *) "-P path...override default file path source/component",
    (TEXT *) "-PA password...password used in conjunction with -u switch",
    (TEXT *) "-S (date)...set the start date for -A switch",
    (TEXT *) "-U user...login as user",
    (TEXT *) "-V verbose...list files written by -A switch",
    (TEXT *) "-W writing...run marion optimized for documentation",
    (TEXT *) "-X exclude...exclude headers from all files.",
    NULL
    };

static TEXT	*months [] =
    {
    (TEXT *) "JAN",
    (TEXT *) "FEB",
    (TEXT *) "MAR",
    (TEXT *) "APR",
    (TEXT *) "MAY",
    (TEXT *) "JUN",
    (TEXT *) "JUL",
    (TEXT *) "AUG",
    (TEXT *) "SEP",
    (TEXT *) "OCT",
    (TEXT *) "NOV",
    (TEXT *) "DEC",
    0
    }; 

#define HEAD1		(TEXT *) "/*************\thistory\t************\n"
#define HEAD2		(TEXT *) "*\n*\tCOMPONENT: %s\tMODULE: %s\n*\tgenerated by Marion %s\n*\tfrom %s db\ton %s\n"
#define HEAD3		(TEXT *) "*****************************************************************\n*\n"
#define TAG		"*\t%ld\t%s\t%s\n*\t%s\n*\n"         /*user, date, change tag */
#define COMMENT_END	(TEXT *) "*/\n\f\n" 
#define TAIL		(TEXT *) "*/\n"
#define DOC_DB           "source/gus.gdb"

#ifdef DECOSF
#define MAIL_PROGRAM	"Mail"
#endif

#ifdef hpux
#define MAIL_PROGRAM	"mailx"
#endif

#ifndef MAIL_PROGRAM
#define MAIL_PROGRAM	"mail"
#endif

typedef struct d_stck {
    TEXT		module [40];
    TEXT		comp [40];
    struct d_stck	*next;
} *D_STCK;

static TEXT	*qual_strings [] = {
    (TEXT *) "gds_",
    (TEXT *) "GDS_",
    (TEXT *) "PYXIS_",
    (TEXT *) "pyxis_",
    (TEXT *) "blob_",
    (TEXT *) "BLOB_",
    0};

static int	cancel_edit PROTO ((void));
static TEXT	*compare PROTO ((TEXT *, TEXT *));
static int	construct_header PROTO ((TEXT *, TEXT *, BSTREAM *, FILE *));
static int	d_free PROTO ((D_STCK, USHORT));
static int	file_truncate PROTO ((TEXT *, TEXT *));
static TEXT	*find_char PROTO ((TEXT *, TEXT));
static SLONG	get_change_no PROTO ((void));
static int	get_derivatives PROTO ((D_STCK, USHORT));
static int	get_description PROTO ((TEXT *));
static int	get_diffs PROTO ((TEXT *, TEXT *, TEXT *, TEXT *));
static int	get_last_date PROTO ((TEXT *));
static int	header_updatable PROTO ((TEXT *, TEXT *));
static int	init_derivative PROTO ((TEXT *, TEXT *, TEXT *));
static int	list_switches PROTO ((void));
static int	mail_message PROTO ((TEXT *, TEXT *));
static UCHAR	*mpexl_translate_output PROTO ((UCHAR *, UCHAR **));
static int	stack_derivatives PROTO ((TEXT *, TEXT *, D_STCK *));
static int	strip_header PROTO ((FILE *));
static int	translate_in PROTO ((TEXT *, TEXT *, USHORT *));
static int	translate_out PROTO ((UCHAR *, UCHAR *));
static int	updatable_types PROTO ((TEXT *));
static int	update_history PROTO ((TEXT *, TEXT *, TEXT *, TEXT *));
static int	update_summary PROTO ((TEXT *, TEXT *, TEXT *, SLONG));

#ifdef _ANSI_PROTOTYPES_
int STUFF_change (
    TEXT	*comp,
    TEXT	*module,
    TEXT	*infile)
#else
int STUFF_change (comp, module, infile)  
    TEXT	*comp, *module, *infile;
#endif
{
/**************************************
 *
 *	S T U F F _ c h a n g e 
 *
 **************************************
 *
 * Functional description
 *	Return a module to  component
 *	
 *	finish up by doing a make, then recapturing
 *      any source files that derive from the 
 *      returned file on this system
 *
 * **************************************/                
TEXT 	filename [50], diff_file [50], oldfile [50], summary [128];
USHORT	count, d_count;
SLONG	change_num;
D_STCK	d_stack, current;

if (!doc_version)
    {
    if (STUFF_derived (comp, module))
        return FALSE;
    d_count = count = 0;
    current = d_stack = (D_STCK) GDS_ALLOC ((SLONG) sizeof (struct d_stck));
    }

change_num = get_change_no();
printf ("This is change_no: %d.\n",change_num);

strcpy (oldfile, OLDFILE);
mktemp (oldfile); 

if (!STUFF_written_out (comp, module, oldfile, FALSE)) 
    {
    unlink (oldfile);
    printf ("Diffs failed, file open failure\n");
    }              

if (!update_summary (comp, module, summary, change_num))
    return FALSE;

get_description (filename);

if (!STUFF_update_source (module, comp, infile))
    return FALSE;
 
if (!get_diffs (comp, module, oldfile, diff_file))
    printf ("Marion regrets, unable to store diffs, continuing put.\n");

if (!update_history (module, comp, filename, diff_file)) 
    return FALSE;	
    
unlink (filename);
unlink (diff_file);

if (!doc_version)
    {
    d_count += stack_derivatives (module, comp, &current);    

    printf ("---------------------------------------------------------\n");
    printf ("               Remaking %s.\n", comp);
    printf ("---------------------------------------------------------\n");
    }
    
/* if there are no derived files (which should be put back
   in the same transaction to avoid being out of synch),
   then go ahead and commit the transaction now to avoid
   making other people wait for the process */

if (!d_count)
    {
    COMMIT;
    FINISH SMM;
    }

EXEC_run (PUT_TEMPLATE, module, comp, NULL, TRUE);
              
if (!d_count)
    {
    READY dbb_name AS SMM;
    START_TRANSACTION;
    }

if (!doc_version)
    {
    if (d_count)
        get_derivatives (d_stack,d_count);
    
    d_free (d_stack, d_count);
    }

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_checked_out_by_me (
    TEXT	*comp,
    TEXT	*module)
#else
int STUFF_checked_out_by_me (comp, module)
    TEXT	*comp, *module;    
#endif
{
/**************************************
 *
 *	S T U F F _ c h e c k e d _ o u t _ b y _ m e
 *
 **************************************
 *
 * Functional description
 * 	return true if the module is
 *	checked out by the current user.
 *	
 *	Test, in  passing for modules that
 *	aren't checked out by anyone and those
 *	checked out by others.
 *
 **************************************/
int	count;

count = 0;

FOR H IN HISTORY WITH
    H.MODULE EQ module AND
    H.COMPONENT EQ comp AND
    H.RETURN_DATE MISSING AND
    H.CHANGED_BY EQ RDB$USER_NAME
    count++;
END_FOR;

if (count)
    return TRUE;

FOR H IN HISTORY WITH
    H.MODULE EQ module AND
    H.COMPONENT EQ comp AND
    H.RETURN_DATE MISSING
    count++;
END_FOR;

if (count)
    STUFF_error_report (comp, module, 4, NULL);
else
    STUFF_error_report (comp, module, 5, NULL);

return FALSE;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_close_history (
    TEXT	*module,
    TEXT	*comp)
#else
int STUFF_close_history (module, comp)
    TEXT	*module, *comp;
#endif
{
/**************************************
 *
 *	S T U F F _ c l o s e _ h i s t o r y
 *
 **************************************
 *
 * Functional description
 *
 * 	Finish a source store by posting the
 *	return date.
 *
 **************************************/   
struct tm	d;
SLONG 	clock;

clock = time (NULL);
d = *localtime (&clock);

FOR H IN SMM.HISTORY WITH
    H.MODULE EQ module AND
    H.COMPONENT EQ comp AND
    H.RETURN_DATE MISSING

    MODIFY H USING
	gds__encode_date (&d, &H.RETURN_DATE);
    END_MODIFY;

END_FOR;

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_derived (
     TEXT    *comp,
     TEXT    *module)
#else
int STUFF_derived (comp, module)
     TEXT    *comp, *module;   
#endif
{
/**************************************
 *
 *	S T U F F _ d e r i v e d
 *
 **************************************
 *
 * Functional description
 *	Guard against edit of derived file.
 *
 **************************************/
SSHORT	count;

count = 0;

FOR S IN SOURCES WITH
    S.COMPONENT EQ comp AND
    S.MODULE EQ module AND
    S.DERIVED_FROM NOT MISSING 

    printf ("%s in %s is derived from %s.\n",
	module, comp, S.DERIVED_FROM, S.DERIVED_FROM);
    count++;

END_FOR;

return count ? TRUE : FALSE;
}


#ifdef _ANSI_PROTOTYPES_
int STUFF_echo_osname (
   SSHORT	code,
   SSHORT	newline)
#else
int STUFF_echo_osname (code, newline)
   SSHORT	code, newline;              
#endif
{
/**************************************
 *
 *	 S T U F F _ e c h o _ o s n a m e
 *
 **************************************
 *
 * Functional description
 *	Operating system is stored as a SSHORT	
 *	print the corresponding string.  
 *
 **************************************/
TEXT	*name;

if (name = opsys_table [code].os_name)
    {
    printf ("%s", name);     
    if (newline)
	putchar ('\n');
    return TRUE;
    }

return FALSE;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_error_report (
    TEXT 	*component,
    TEXT 	*module,
    SSHORT 	err,
    STATUS	*status)
#else
int STUFF_error_report (component, module, err, status)
    TEXT 	*component, *module;
    SSHORT 	err;
    STATUS	*status;
#endif
{
/**************************************
 *
 *	S T U F F _e r r o r _ r e p o r t
 *
 **************************************
 *
 * Functional description
 *	Puts up error messages.
 *
 **************************************/

if (status && status [1] == isc_integ_fail)
    {
    err = status [3];
    status = NULL;
    }

if (err)
    switch (err) 
	{
	case 1 :
		printf ("\nComponent %s doesn't seem to exist. AC will add it\n", component);
		break;
	case 2 : 
		printf ("\n %s %s already seems to exist.\n", component, module);
		break;

	case 4 : 
		STUFF_who_has (module, component);
		break;
				
	case 5 : 
		printf ("%s in %s is not checked out. Try GM %s.\n",
			module, component, module);
		break;
		
	case 6 : 
		printf ("Component %s already exists in this database.\n", component);
		break;

	case 7 : 
		printf ("Can't open file %s.\n",component);
		break;
	
	case 8 :
		printf ("You don't have %s from %s checked out\n", module, component);
		break;
	}
else if (status)
    gds__print_status (status);
else
    printf ("unspecified catastrophe\n");
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_exists_YN (
    TEXT	*component,
    TEXT	*module)   
#else
int STUFF_exists_YN (component, module)
    TEXT	*component, *module;   
#endif
{
/**************************************
 *
 *	S T U F F _ e x i s t s _ Y N
 *
 **************************************
 *
 * Functional description
 *	Finds component and module if they exist.
 *
 **************************************/
int	count;

count = 0;

FOR X IN SOURCES WITH
    X.MODULE EQ module AND X.COMPONENT EQ component

    count++;

END_FOR; 

if (!count)
    {
    printf ("Alas, %s in %s can't be found in this database.\n",
	module, component);
    return FALSE;
    }

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_get_filename (
   TEXT	*module,
   TEXT	*filename) 
#else
int STUFF_get_filename (module, filename)
   TEXT	*module, *filename; 
#endif
{
/**************************************
 *
 *	S T U F F _ g e t _ f i l e n a m e
 *
 **************************************
 *
 * Functional description
 *	Build filename starting from module if no name supplied.
 *
 **************************************/
TEXT 	buffer [128];

if (NULL_STR (filename))  	
    STUFF_lowcase (module, filename);

if (NOT_NULL (pathname))
    {
    strcpy (buffer, pathname);
    strcat (buffer, filename);
    strcpy (filename, buffer);
    }
}
          
#ifdef _ANSI_PROTOTYPES_
int STUFF_get_string (
    SCHAR	*prompt_string,
    SCHAR	*response_string,
    int		length)
#else
int STUFF_get_string (prompt_string, response_string, length)
    SCHAR	*prompt_string, *response_string;
    int		length;
#endif
{
/**************************************
 *
 *	S T U F F _ g e t _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *	Write a prompt and read a string.  If the string overflows,
 *	try again.  If we get an EOF, return FAILURE.
 *
 **************************************/          
SCHAR	*p;
SSHORT	l, c;

while (TRUE)
    {
    printf ("%s: ", prompt_string);
    for (p = response_string, l = length; l; --l)
	{
	c = getchar();
	if (c == EOF)
	    return FALSE;
	if (c == '\n')
	    {
	    *p = 0;
	    return TRUE;
	    }
	*p++ = c;
	}
    while (getchar() != '\n')
	;
    printf ("** Maximum field length is %d characters **\n", length - 1);
    }
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_get_summary (
	TEXT	*buffer,
 	int	len)   
#else
int STUFF_get_summary (buffer, len)
	TEXT	*buffer;
 	int	len;   
#endif
{
/**************************************
 *
 *	S T U F F _ g e t _ s u m m a r y 
 *
 **************************************
 *
 * Functional description
 * 	Get a line of summary description of
 *	change, being a little picky about the
 *	shortness of some answers.
 *	
 *	This routine is used to get new summary
 *	lines and to update an existing line.
 *
 **************************************/
TEXT	s [20];

if (*buffer)
    {
    printf("The summary of the changes reads:\n    \"%s\"\n", buffer);
    STUFF_get_string  ("Do you want to change it? ", s, sizeof (s));
    if (*s != 'y' && *s != 'Y')
	return TRUE;
    }
	
while (STUFF_get_string ("Type a summary line", buffer, len))
    {
    if (strlen (buffer) >= 6) 
	return TRUE;
    printf ("Too short, try again.\n");
    }

return FALSE;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_handle_switches (
    SSHORT	argc,
    SCHAR	*argv[],     
    TEXT	*dbb_name)
#else
int STUFF_handle_switches (argc, argv, dbb_name)
    SSHORT	argc;
    SCHAR	*argv[];     
    TEXT	*dbb_name;
#endif
{
/**************************************
 *
 *	S T U F F _ h a n d l e _ s w i t c h e s
 *
 **************************************
 *
 * Functional description
 *	Parses the command line switches.
 *
 **************************************/
TEXT 	*p, opsys [20], **ptr;
USHORT	share_command, cmd_line_err;

/* Initialize a string translation table for translate_in/out */

for (ptr = qual_strings; *ptr; ptr++)
    vector [(unsigned int) **ptr] = (*ptr) + 1;

share_command = cmd_line_err = smm_version = FALSE;
headers = -1;

while (argc-- > 0)
    {
    p = (TEXT *) *argv++;
    if (*p++ != '-')
	continue;
    switch (UPPER (*p))
	{
	case 'A':
	    share_command = TRUE;
	    break;

	case 'D':
	    if (argc && (**argv != '-'))
		{
		strcpy (dbb_name, *argv++);
		--argc;
		}
	    else
		cmd_line_err = TRUE;
	    break;

	case 'C':
	    if (argc && (**argv != '-'))
		{
		STUFF_upcase (*argv++, component);
		--argc;
		}
	    else
		cmd_line_err = TRUE;
	    break;

	case 'H':
	    headers = TRUE;
	    break;

	case 'L':
	    if (argc && (**argv != '-'))
		{
                log_info = TRUE;
		STUFF_upcase (*argv++, log_name);
		--argc;
		}
	    else
		cmd_line_err = TRUE;
	    break;

	case 'O':
	    if (argc && (**argv != '-'))
		{
		strcpy (opsys,*argv++);
		op_sys_code = STUFF_set_oscode(opsys);
		--argc;
		}
	    else
		cmd_line_err = TRUE;
	    break;

	case 'P':
	    if (!(argc && (**argv != '-')))
		cmd_line_err = TRUE;
	    else
		{
		p++;
		if (UPPER (*p) != 'A')
		    strcpy (pathname, *argv++);
		else
		    strcpy (password, *argv++);
		--argc;
		}
	    break;	

	case 'S':
	    smm_since = TRUE;
	    if (argc && (**argv != '-'))
		{
		strcpy (share_since_date, *argv++);
		--argc;
		}
	    break;

	case 'U':
	    if (argc && (**argv != '-'))
		{
		strcpy (user_name, *argv++);
		--argc;
		}
	    else
		cmd_line_err = TRUE;
	    break;	

	case 'V':
	    verbose = TRUE;	
	    break;

	case 'W':
	    doc_version = TRUE;	
	    strcpy (dbb_name, DOC_DB);
	    break;

	case 'X':
	    headers = FALSE;
	    break;

        case 'Z':
	    smm_version = TRUE; 
	    break;

	default:
	    cmd_line_err = TRUE;
	    break;
	}
    }


if (cmd_line_err)
    {
    list_switches();
    exit (1);
    }

if (smm_since && !share_command)
    exit(1);

return share_command;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_init_source (
    TEXT    *comp,
    TEXT    *module)
#else
int STUFF_init_source (comp, module)
    TEXT    *comp, *module;
#endif
{
/**************************************
 *
 *	S T U F F _ i n i t _ s o u r c e
 *
 **************************************
 *
 * Functional description
 *   	
 **************************************/
TEXT	*c, filetype [6];

STORE S IN SMM.SOURCES USING 
    strncpy (S.MODULE, module, 39);
    strncpy (S.COMPONENT, comp, 19);
    if ((c = find_char (module, '.')) != NULL)
	{
	c++;
        strncpy (filetype, c, 5);
        filetype [5] = 0;
	strcpy (S.FILE_TYPE, filetype);
	}
    else                    
	S.FILE_TYPE [0] = 0;

    if (updatable_types (S.FILE_TYPE))
	S.FLAGS = 0;
    else
	S.FLAGS = FLAGS_noheader;
END_STORE
    ON_ERROR
	{
	STUFF_error_report (comp, module, 0, gds__status);
	return FALSE;
	}
    END_ERROR;

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_loop_change (
    TEXT	*start_comp)
#else
int STUFF_loop_change (start_comp)  
    TEXT	*start_comp;
#endif
{
/**************************************
 *
 *	S T U F F _  l o o p _ c h a n g e 
 *
 **************************************
 *
 * Functional description
 *	Return several modules to a single component
 *	all at once and without doing a make
 *	for each one. 
 *	
 *	finish up by doing a make, then recapturing
 *      any source files that derive from the 
 *      returned files on this system
 *
 **************************************/
TEXT	comp [50];
TEXT	buffer [128], module [50], infile[50], summary[128];
TEXT 	filename[50], diff_file[50], oldfile[50];
int	n, count, d_count;
SLONG	change_num;
D_STCK  d_stack, current;

strcpy (comp, start_comp);
if (!doc_version)
    {
    d_count = count = 0;
    current = d_stack = (D_STCK) GDS_ALLOC ((SLONG) sizeof (struct d_stck));
    }

change_num = get_change_no();
printf ("These changes are grouped under change_no: %d.\n", change_num);

get_description (filename);

printf ("Type...module name, file name\n");
printf ("quit or ctrl-D (on Apollo ctrl-Z) will return to command level.\n");

while (STUFF_get_string ("put> ", buffer, sizeof (buffer)))
    {
    module [0] = infile [0] = 0;
    n = sscanf (buffer, "%s%s", module, infile);
    if (n <= 0)
	continue;

    STUFF_upcase (module, module);

    if (!strcmp (module, "QUIT"))
	break;

    if (!strcmp (module, "SC"))
	{
	if (infile [0])
	    {
	    set_component (infile);
	    strcpy (comp, component);
	    }
	continue;
	}

    if (STUFF_derived (comp, module) ||
	!STUFF_checked_out_by_me (comp, module))
	continue;

    strcpy (oldfile, OLDFILE);
    mktemp (oldfile); 
    
    if (!STUFF_written_out (comp, module, oldfile, FALSE)) 
        {
        unlink (oldfile);
        printf ("Diffs failed, file open failure. Put continues...\n");
        }              
	     
    if (!update_summary (comp, module, summary, change_num))
        return FALSE;

    if (!STUFF_update_source (module, comp, infile))
        return FALSE;
 
    if (!get_diffs (comp, module, oldfile, diff_file))
        continue;

    if (!update_history (module, comp, filename, diff_file)) 
        return FALSE;	
   
    unlink (diff_file);

    STUFF_notify_queue (comp, module);
  
    if (!doc_version)
        d_count += stack_derivatives (module, comp, &current);    

    EXEC_run (MPP_TEMPLATE, module, comp, NULL, TRUE);

    count++;
    }

unlink (filename);

if (count)
    {
    if (!doc_version)
	{
        printf ("---------------------------------------------------------\n");
	printf ("               Remaking %s.\n", comp);
        printf ("---------------------------------------------------------\n");
	}

    if (!d_count)
        {
        COMMIT;
        FINISH SMM;
        }

    EXEC_run (MPM_TEMPLATE, comp, NULL, NULL, TRUE);

    if (!d_count)
        {
        READY dbb_name AS SMM;
        START_TRANSACTION;
        }

    if (!doc_version)
	{
        if (d_count)
            get_derivatives (d_stack,d_count);
        d_free (d_stack, d_count);
	}
    }

return count; 
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_loop_share (
   TEXT		*comp) 
#else
int STUFF_loop_share (comp)
   TEXT		*comp; 
#endif
{
/**************************************
 *
 *	S T U F F _ l o o p _ s h a r e
 *
 **************************************
 *
 * Functional description
 *	Share all the modules in a given component.
 *
 **************************************/

FOR S IN SOURCES WITH
    S.COMPONENT EQ comp

    if (S.FLAGS.NULL || !(S.FLAGS & FLAGS_obsolete))
	STUFF_share_a_module (comp, S.MODULE, NULL);

END_FOR;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_loop_share_since (
   TEXT		*comp,
   TEXT		*date) 
#else
int STUFF_loop_share_since (comp, date)
   TEXT		*comp, *date; 
#endif
{
/**************************************
 *
 *	S T U F F _ l o o p _ s h a r e _ s i n c e
 *
 **************************************
 *
 * Functional description
 *	Share all the modules in a given component
 *	modified since a given date (on or after date)
 * 12/15 loop through derived files added
 *
 **************************************/

FOR H IN HISTORY WITH
    H.COMPONENT EQ comp AND
    H.RETURN_DATE.CHAR[20] GE date
    REDUCED TO H.MODULE

    FOR S IN SOURCES WITH
	S.COMPONENT EQ H.COMPONENT AND
	S.MODULE EQ H.MODULE

	if (S.FLAGS.NULL || !(S.FLAGS & FLAGS_obsolete))
	    STUFF_share_a_module (comp, S.MODULE, NULL);

    END_FOR;

END_FOR;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_lowcase (
   TEXT 	*word,
   TEXT 	*lword) 
#else
int STUFF_lowcase (word, lword)
   TEXT 	*word, *lword; 
#endif
{
/**************************************
 *
 *	S T U F F _ l o w c a s e
 *
 **************************************
 *
 * Functional description
 *	Copies word to lword making sure alpha
 *	chars are lowercase.
 *
 **************************************/
TEXT	c;

while ((c = *word++) && c != ' ')
    *lword++ = LOWER (c);

*lword = 0;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_manage_component (
    TEXT 	*comp)
#else
int STUFF_manage_component (comp)
    TEXT 	*comp;
#endif
{
/**************************************
 *
 *	S T U F F _ m a n a g e _ c o m p o n e n t
 *
 **************************************
 *
 * Functional description
 * 	Check to see if a component is already set
 *	if not, prompt for one
 *
 **************************************/

if (NULL_STR(component))
    {
    STUFF_get_string ("\nEnter the component name", comp, 20);
    STUFF_upcase (comp, comp);
    }
else
    strcpy (comp, component);
}

#ifdef _ANSI_PROTOTYPES_
FILE *STUFF_manage_fopen (
    TEXT    *module,
    TEXT    *infile,
    TEXT    *mode)    
#else
FILE *STUFF_manage_fopen (module, infile, mode)
    TEXT    *module, *infile, *mode;    
#endif
{
/**************************************
 *
 *	S T U F F _ m a n a g e _ f o p e n 
 *
 **************************************
 *
 * Functional description
 *	Get the filename and open the file.
 *
 **************************************/ 
FILE    *infp;

STUFF_get_filename (module, infile);

if ((infp = fopen (infile, mode)) == NULL)
	STUFF_error_report (infile, NULL, 7, NULL);

return (infp);
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_notify_queue (
   TEXT		*comp,
   TEXT		*module)
#else
int STUFF_notify_queue (comp,module)
   TEXT		*comp, *module;
#endif
{
/**************************************
 *
 *	S T U F F _ n o t i f y _ q u e u e
 *
 **************************************
 *
 * Functional description
 *	Notify the next person in the queue 
 *	of the availability of the module.
 *         
 **************************************/
TEXT	message [256];

FOR FIRST 1 Q IN QUEUE WITH
    Q.COMPONENT EQ comp AND 
    Q.MODULE EQ module
    SORTED BY ASCENDING Q.DATE

    /* notify the next in queue of the checkin */
   
    sprintf (message, "This is marion.\nThe module %s in component %s \
has been released.\nYou are next in line to use it.\n", module, comp);

    printf ("Notifying user %s that %s is available.\n", Q.USR, module);
    mail_message (message, Q.USR);
    
    ERASE Q;

END_FOR;
}


#ifdef _ANSI_PROTOTYPES_
int STUFF_obsolete (
    TEXT    *comp,
    TEXT    *module)
#else
int STUFF_obsolete (comp, module)
    TEXT    *comp, *module;
#endif
{
/**************************************
 *
 *        S T U F F _ o b s o l e t e	
 *
 **************************************
 *
 * Functional description
 *     Boolean function checks if flags is set or not.
 *
 **************************************/
USHORT	count;

count = 0;

FOR S IN SOURCES WITH
    S.COMPONENT EQ comp AND
    S.MODULE EQ module

    if (!S.FLAGS.NULL && S.FLAGS & FLAGS_obsolete)
	count++;

END_FOR;

if (count)
    printf ("%s in %s is obsolete.\n", module, comp);

return count ? TRUE : FALSE;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_report_history (
   TEXT		*comp,
   TEXT		*module)
#else
int STUFF_report_history (comp,module)
   TEXT		*comp, *module;
#endif
{
/**************************************
 *
 *	S T U F F _ r e p o r t _ h i s t o r y
 *
 **************************************
 *
 * Functional description
 *	Print out a history report for
 *	this component and module.
 *
 **************************************/

FOR H IN HISTORY WITH
    H.COMPONENT EQ comp AND 
    H.MODULE EQ module AND
    H.RETURN_DATE NOT MISSING
    SORTED BY H.RETURN_DATE

    printf ("%s   %s %s\n%s\n",
	H.MODULE, H.RETURN_DATE.CHAR[20], H.CHANGED_BY,  H.CHANGE_TAG);

END_FOR;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_set_oscode (
    TEXT 	*ops)
#else
int STUFF_set_oscode (ops)
    TEXT 	*ops;
#endif
{
/**************************************
 *
 *	S T U F F _ s e t _ o s c o d e
 *
 **************************************
 *
 * Functional description
 *	Loop through the opsys_table to find a 
 *	string that matches the OPS passed in.
 *	
 **************************************/
OS_TAB 	*ptr;

STUFF_upcase (ops, ops);

for (ptr = opsys_table; ptr->os_name; ptr++)
    if (strcmp (ops, ptr->os_name) == 0)
	break;

return (ptr->os_number);
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_share_a_module (
    TEXT	*comp,
    TEXT	*module,
    TEXT	*outfile)
#else
STUFF_share_a_module (comp, module, outfile)
    TEXT	*comp, *module, *outfile;
#endif
{
/**************************************
 *
 *	S T U F F _ s h a r e _ a _ m o d u l e
 *
 **************************************
 *
 * Functional description
 *	Share all the modules in a given component.
 *
 **************************************/
TEXT	filename [128];

if (!outfile)
    {
    outfile = filename;
    STUFF_lowcase (module, outfile);
    }

STUFF_written_out (comp, module, outfile, headers);
if (log_info)
    STORE EF IN EXTRACT_FILES
	strcpy (EF.LOG_NAME, log_name);
	strcpy (EF.DATE.CHAR[12], "today");
	strcpy (EF.COMPONENT, component);
	strcpy (EF.MODULE, module);
    END_STORE;

FOR D IN SOURCES WITH
    D.DERIVED_FROM EQ module AND
    D.COMPONENT EQ comp

    STUFF_lowcase (D.MODULE, filename);
    STUFF_written_out (comp, D.MODULE, filename, headers);
    if (log_info)
	STORE EF IN EXTRACT_FILES
	    strcpy (EF.LOG_NAME, log_name);
	    strcpy (EF.DATE.CHAR[12], "today");
	    strcpy (EF.COMPONENT, component);
	    strcpy (EF.MODULE, D.MODULE);
	END_STORE;

END_FOR;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_share_command (void)
#else
int STUFF_share_command ()
#endif
{
/**************************************
 *
 *	S T U F F _ s h a r e _ c o m m a n d
 *
 **************************************
 *
 * Functional description
 * 	Manage a share of all modules in a 
 *	component from the command line.
 *
 **************************************/

set_component (component);

if (NULL_STR (component))
    return;

if (smm_since)
    {
    if (NOT_NULL(share_since_date)) 
        STUFF_loop_share_since (component, share_since_date); 
    else
        {
        if (get_last_date(share_since_date))
	    STUFF_loop_share_since (component, share_since_date);  
        else
            exit(1);	    
        }	
    if (log_info)
        STORE E IN EXTRACTS
            strcpy (E.LOG_NAME, log_name);
            strcpy (E.DATE.CHAR[12], "today");
            strcpy (E.COMPONENT, component);
            strcpy (E.SINCE.CHAR[20], share_since_date);
        END_STORE;
    }
else
    {
    STUFF_loop_share (component);
    if (log_info)
        STORE E IN EXTRACTS
            strcpy (E.LOG_NAME, log_name);
            strcpy (E.DATE.CHAR[12], "today");
            strcpy (E.COMPONENT, component);
        END_STORE;
    }
return;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_signal_quit (void)
#else
STUFF_signal_quit ()
#endif
{
/**************************************
 *
 *	S T U F F _ s i g n a l _ q u i t
 *
 **************************************
 *
 * Functional description
 *	Handle a quit signal.
 *
 **************************************/

quit = TRUE;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_store_derivative (
    TEXT    *module,
    TEXT    *comp)    
#else
int STUFF_store_derivative (module, comp)
    TEXT    *module, *comp;    
#endif
{
/**************************************
 *
 *	S T U F F _ s t o r e _ d e r i v a t i v e
 *
 **************************************
 *
 * Functional description
 *	Handle record keeping and file capture for all
 *      derivatives of a module.
 *
 **************************************/
TEXT	derivative [80], answer [80],infile [80];
struct	tm	d;
SLONG 	clock;

clock = time (NULL);
d = *localtime (&clock);

printf ("\nType the name of the derived file,'QUIT' to exit\n");
printf ("'A!' to abandon the add_module\n\n");
             
for (;;)
    {
    STUFF_get_string ("Filename, QUIT or A!", derivative, sizeof(derivative));

    STUFF_upcase (derivative, answer);

    if (!(strcmp ("A!", answer)))
    return FALSE;

    if (!(strcmp ("QUIT", answer)))
    return TRUE;

    if (!(init_derivative (comp, module, derivative)))
        return FALSE;

    *infile = 0;
    if (!(STUFF_update_source (derivative, comp, infile)))
	return FALSE; 

    FOR H IN HISTORY WITH
	H.COMPONENT EQ comp AND
        H.MODULE EQ derivative

	MODIFY H USING
	    gds__encode_date (&d, &H.RETURN_DATE);
        END_MODIFY;

    END_FOR;
    }
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_store_history (
    TEXT	*comp,
    TEXT	*module)    
#else
int STUFF_store_history (comp, module)
    TEXT	*comp, *module;    
#endif
{
/**************************************
 *
 *	S T U F F _ s t o r e _ h i s t o r y
 *
 **************************************
 *
 * Functional description
 *	Store a new history record,
 *	being somewhat careful to avoid
 *	asking the user for input then
 *	bombing because the module was
 *	already out.
 *
 *	The check that a module is out is
 *	done by the store trigger.
 *
 **************************************/
TEXT	*c, *s, host [20], dir [128];
int	i;
                    
STORE  H IN SMM.HISTORY USING 
    strncpy (H.MODULE, module, 39);
    strncpy (H.COMPONENT, comp, 19);
    if (EXEC_get_host_dir(host, dir))
	{
        gds__vtov (host, H.HOST, sizeof (H.HOST));
        gds__vtov(dir, H.WHERE, sizeof (H.WHERE));
	}
END_STORE
    ON_ERROR
	{
	STUFF_error_report (comp, module, 0, gds__status);
	return FALSE;
	}
    END_ERROR;

/* do a dummy update to the source relation
   to prevent two people from checking out a
   module with concurrent transactions */

FOR S IN SMM.SOURCES WITH
    S.MODULE EQ module AND
    S.COMPONENT EQ comp

    MODIFY S
    END_MODIFY;

END_FOR
    ON_ERROR
	{
	STUFF_error_report (comp, module, 0, gds__status);
	return FALSE;
	}
    END_ERROR;

FOR H IN SMM.HISTORY WITH
    H.MODULE EQ module AND
    H.COMPONENT EQ comp AND
    H.RETURN_DATE MISSING

    MODIFY H USING
	while (!STUFF_get_summary (H.CHANGE_TAG, 80))
	    if (cancel_edit())
		return FALSE;
    END_MODIFY;

END_FOR;

return TRUE;
}             

#ifdef _ANSI_PROTOTYPES_
int STUFF_store_queue (
    TEXT	*comp,
    TEXT	*module)    
#else
int STUFF_store_queue (comp, module)
    TEXT	*comp, *module;    
#endif
{
/**************************************
 *
 *	S T U F F _ s t o r e _ q u e u e
 *
 **************************************
 *
 * Functional description
 *	Store the user into the queue of people
 *	waiting for a particular module.
 *
 **************************************/
TEXT	message [256], user_name [32], checkout_user [32];
USHORT	found = 0;

/* the date and the user name will be filled in
   by the trigger */
                    
STORE Q IN SMM.QUEUE USING 
    strncpy (Q.MODULE, module, 39);
    strncpy (Q.COMPONENT, comp, 19);
END_STORE
    ON_ERROR
	{
	STUFF_error_report (comp, module, 0, gds__status);
	return FALSE;
	}
    END_ERROR;

FOR Q2 IN SMM.QUEUE WITH
    Q2.COMPONENT EQ comp AND
    Q2.MODULE EQ module
    SORTED BY DESCENDING Q2.DATE

    if (!found)
	strcpy (user_name, Q2.USR);
    found++;
    if (found > 1)
	break;

END_FOR
    ON_ERROR
	{
	STUFF_error_report (comp, module, 0, gds__status);
	return FALSE;
	}
    END_ERROR;

/* if this is the first person waiting, notify the 
   person who has the module out */

if (found == 1)
    FOR H IN HISTORY WITH
        H.MODULE EQ module AND
        H.COMPONENT EQ comp AND
        H.RETURN_DATE MISSING

        sprintf (message, "This is marion.\n%s is waiting for \
the module\n%s in component %s.\n", user_name, module, comp);

        printf ("Notifying user %s that you are waiting for %s.\n", H.CHANGED_BY, module);
        mail_message (message, H.CHANGED_BY);

    END_FOR;


}             

#ifdef _ANSI_PROTOTYPES_
int STUFF_upcase (
    TEXT	*string,
    TEXT	*name)
#else
STUFF_upcase (string, name)
    TEXT	*string, *name;
#endif
{
/**************************************
 *
 *	S T U F F _ u p c a s e
 *
 **************************************
 *
 * Functional description
 *	Translate a string into a name.  The string may be either
 *	blank or null terminated.  The output name is null terminated.
 *
 **************************************/
TEXT	c;

while ((c = *string++) && c != ' ')
    *name++ = UPPER (c);

*name =0;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_update_source (
    TEXT	*module,
    TEXT	*comp,
    TEXT	*infile)
#else
int STUFF_update_source (module, comp, infile)
    TEXT	*module, *comp, *infile;
#endif
{
/**************************************
 *
 *	S T U F F _ u p d a t e _ s o u r c e
 *
 **************************************
 *
 * Functional description
 *   Put a file into marion.  This
 *   happens just before a history record
 *   gets updated.
 *
 *   We just pass in the module, component,
 *   and a potential file name and this does
 *   the rest.
 *
 **************************************/
TEXT	buffer [256], output [256];
TEXT	*bufptr, *b, c;
BSTREAM	*src;
FILE	*infp;
USHORT   oscode;

if (doc_version)
    {
    if (NULL_STR (infile))
	STUFF_lowcase (module, infile);
    FOR S IN SMM.SOURCES WITH
	S.COMPONENT EQ comp AND S.MODULE EQ module

        MODIFY S USING
            BLOB_load (&S.SOURCE, SMM, gds__trans, infile);
        END_MODIFY
        ON_ERROR
            {
            STUFF_error_report (comp, module, 0, gds__status);
            return FALSE;
            }
        END_ERROR;

    END_FOR;
    return TRUE;
    }

if ((infp = STUFF_manage_fopen (module, infile, "r")) == NULL) 
    return FALSE;

oscode = 0;

if (capabilities & CAP_header_field)
    {
    FOR S IN SMM.SOURCES WITH
	S.COMPONENT EQ comp AND S.MODULE EQ module

	MODIFY S USING
	    if ((S.FLAGS.NULL || !(S.FLAGS & FLAGS_noheader)) &&
		(src = Bopen (&S.HEADER, SMM, gds__trans, "w")))
		{
		construct_header (comp, module, src, NULL);
		BLOB_close (src);
		S.HEADER.NULL = FALSE;
		}
	    else
		S.HEADER.NULL = TRUE;

	    if (src = Bopen (&S.SOURCE, SMM, gds__trans, "w"))
		{  
		strip_header (infp);

		while (fgets (buffer, sizeof (buffer), infp))
		    {
		    if (!(translate_in (buffer, output, &oscode)))
			bufptr = buffer;
		    else
			bufptr = output;
		    while (c = *bufptr++)
			putb (c, src);
		    }
		BLOB_close (src);
		fclose (infp);
		}
	END_MODIFY
	ON_ERROR
	    {
	    STUFF_error_report (comp, module, 0, gds__status);
	    return FALSE;
	    }
	END_ERROR;

    END_FOR;
    }
else
    {
    FOR S IN SMM.SOURCES WITH
	S.COMPONENT EQ comp AND S.MODULE EQ module

	MODIFY S USING
	    if (src = Bopen (&S.SOURCE, SMM, gds__trans, "w"))
		{  
		if (header_updatable (module, comp))
                    construct_header (comp, module, src, NULL);

		strip_header (infp);

		while (fgets (buffer, sizeof (buffer), infp))
		    {
		    if (!(translate_in (buffer, output, &oscode)))
			bufptr = buffer;
		    else
			bufptr = output;
		    while (c = *bufptr++)
			putb (c, src);
		    }
		BLOB_close (src);
		fclose (infp);
		}
	END_MODIFY
	ON_ERROR
	    {
	    STUFF_error_report (comp, module, 0, gds__status);
	    return FALSE;
	    }
	END_ERROR;

    END_FOR;
    }

if ((op_sys_code != OS_PC) && (oscode == 1))
    STUFF_written_out (comp, module, infile, FALSE); 

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_use_argfile (
    TEXT	*dbb_name)
#else
int STUFF_use_argfile (dbb_name)
    TEXT	*dbb_name;
#endif
{
/**************************************
 *
 *	S T U F F _ u s e _ a r g f i l e
 *
 **************************************
 *
 * Functional description
 *	Open an argfile if any and assign
 *	the contents to the appropriate global variables.
 *
 **************************************/                
FILE 	*fp;
TEXT 	tempname[128], tempcomp[20], tempops[10], temppath[60];
SSHORT	n;

if ((fp = fopen ("marion.arg","r")) == NULL ||
    !(n = fscanf (fp, "%s%s%s%s", tempname, tempcomp, tempops, temppath)))
    return;

if (*tempname != '0')
    strcpy (dbb_name, tempname);

if (!--n)
    return;

if (*tempcomp != '0')
    strcpy (component, tempcomp);

if (!--n)
    return;

if (*tempops != '0')
    op_sys_code = STUFF_set_oscode (tempops);

if (!--n)
    return;

if (*temppath != '0')
    strcpy (pathname, temppath);
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_who_has (
    TEXT	*module,
    TEXT	*comp) 
#else
int STUFF_who_has (module, comp)
    TEXT	*module, *comp; 
#endif
{
/**************************************
 *
 *	S T U F F _ w h o _ h a s
 *
 **************************************
 *
 * Functional description
 *	Displays current holder of the 
 *	specified module on the screen.
 *
 **************************************/   
USHORT	count;
 
count = 0;

FOR H IN HISTORY WITH
    H.MODULE EQ module AND
    H.COMPONENT EQ comp AND
    H.RETURN_DATE MISSING

    printf ("%s in %s is checked out by %s.\n", module, comp, H.CHANGED_BY);
    count++;

END_FOR;        

return count;
}

#ifdef _ANSI_PROTOTYPES_
int STUFF_written_out (
    TEXT 	*comp,
    TEXT 	*module,
    TEXT 	*outfile,
    SSHORT	with_header)
#else
int STUFF_written_out (comp, module, outfile, with_header)
    TEXT 	*comp, *module, *outfile;
    SSHORT	with_header;
#endif
{
/**************************************
 *
 *	S T U F F _ w r i t t e n _ o u t 
 *
 **************************************
 *
 * Functional description               
 *	This handles opening an output file and moving
 *	blob contents through the translate_out function
 *	and to the output file.
 *
 **************************************/   
UCHAR 	buffer [257], output [257], *bufptr;  
FILE    *outfp;

/*  For MPEXL, compress the output file name.  */

if (op_sys_code == OS_MPEXL)
    {
    MPEXL_compress_name (comp, module, outfile);
    STUFF_lowcase (outfile, outfile);
    }
#ifndef PC_PLATFORM
else if (op_sys_code == OS_PC)
    {
    if (NULL_STR (outfile))
	STUFF_lowcase (module, outfile);
    file_truncate (outfile, outfile);
    }
#endif

if (doc_version)
    {
    if (NULL_STR (outfile))
	STUFF_lowcase (module, outfile);
    FOR S IN SMM.SOURCES WITH S.MODULE EQ module AND S.COMPONENT EQ comp
        BLOB_dump (&S.SOURCE, SMM, gds__trans, outfile);
    END_FOR;
    return TRUE;
    }

if ((outfp = STUFF_manage_fopen (module, outfile, "w")) == NULL) 
    return FALSE;

if (capabilities & CAP_header_field)
    {
    FOR S IN SMM.SOURCES WITH S.MODULE EQ module AND S.COMPONENT EQ comp
	if (with_header == TRUE ||
	    (with_header != FALSE && (S.FLAGS.NULL || !(S.FLAGS & FLAGS_noheader))))
	    if (!S.HEADER.NULL)
		{
		FOR BLB IN S.HEADER
		    strncpy (buffer, BLB.SEGMENT, BLB.LENGTH);
		    buffer [BLB.LENGTH] = 0;
		    fputs (buffer, outfp);
		END_FOR;                  
		}
	    else if (with_header == TRUE || !S.FLAGS.NULL)
		construct_header (comp, module, NULL, outfp);

	FOR BLB IN S.SOURCE
	    strncpy (buffer, BLB.SEGMENT, BLB.LENGTH);
	    buffer [BLB.LENGTH] = 0;
	    if (!(translate_out (buffer, output)))
		bufptr = buffer;
	    else
		bufptr = output;
	    fputs (bufptr, outfp);
	END_FOR;                  
    END_FOR;
    }
else
    {
    FOR S IN SMM.SOURCES WITH S.MODULE EQ module AND S.COMPONENT EQ comp
	FOR BLB IN S.SOURCE
	    strncpy (buffer, BLB.SEGMENT, BLB.LENGTH);
	    buffer [BLB.LENGTH] = 0;
	    if (!(translate_out (buffer, output)))
		bufptr = buffer;
	    else
		bufptr = output;
	    fputs (bufptr, outfp);
	END_FOR;                  
    END_FOR;
    }
                               
fclose (outfp);

if (verbose || op_sys_code == OS_MPEXL)
    printf ("%s %s %s\n", comp, module, outfile);

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
static int cancel_edit (void)
#else
static int cancel_edit ()
#endif
{
/**************************************
 *
 *	c a n c e l _ e d i t
 *
 **************************************
 *
 * Functional description
 *	We've got EOF on a prompt which
 *	may mean that the user is tired of
 *	the edit and wants to stop.
 *
 **************************************/
TEXT	s [4];


if (STUFF_get_string ("do you want to abandon the edit?", s, sizeof (s)))
    if (*s == 'n' || *s == 'N')
	return FALSE;

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
static TEXT *compare (
    TEXT	*s1,
    TEXT	*s2)
#else
static TEXT *compare (s1, s2)
    TEXT	*s1, *s2;
#endif
{
/**************************************
 *
 *	c o m p a r e
 *
 **************************************
 *
 * Functional description
 *
 **************************************/

if (!s1)
    return NULL;

while (*s1)
    if (*s1++ != *s2++)
	return NULL;

return s2;
}

#ifdef _ANSI_PROTOTYPES_
static int d_free (
    D_STCK	d_stack,
    USHORT	d_count)    
#else
static d_free (d_stack, d_count)
    D_STCK	d_stack;
    USHORT	d_count;    
#endif
{
/**************************************
 *
 *	d _ f r e e 
 *
 **************************************
 *
 * Functional description
 *	Free any d_stack storage that has
 *	been allocated.
 *
 **************************************/
D_STCK	used;

while (d_count--)
    { 
    used = d_stack;
    d_stack = d_stack->next;
    gds__free (used);
    }

gds__free (d_stack);
}

#ifdef _ANSI_PROTOTYPES_
static int file_truncate (
    TEXT	*in,
    TEXT	*out)
#else
static file_truncate (in, out)
    TEXT	*in, *out;
#endif
{
/**************************************
 *
 *	f i l e _ t r u n c a t e
 *
 **************************************
 *
 * Functional description
 *	Copy a filename, truncating
 *	the part before the period.
 *
 **************************************/
TEXT	*end;
         
for (end = out + 8; *in && *in != '.'; in++)
    if (out < end)
	*out++ = *in;

while (*out++ = *in++)
    ;
}

#ifdef _ANSI_PROTOTYPES_
static TEXT *find_char (
    TEXT *s,
    TEXT c)
#else
static TEXT *find_char (s, c)
    TEXT *s;
    TEXT c;
#endif
{
/**************************************
 *
 *	f i n d _ c h a r
 *
 **************************************
 *
 * Functional description
 *	Return a pointer to the first occurrence of
 *	c in s (integer) return -1 for failure	.
 *
 **************************************/

while ((*s) && (*s != c))
    s++;

return (*s) ? s : NULL;
}       

#ifdef _ANSI_PROTOTYPES_
static SLONG get_change_no (void)
#else
static SLONG get_change_no ()
#endif
{
/**************************************
 *
 *	g e t _ c h a n g e _ n o
 *
 **************************************
 *
 * Functional description 
 *	Get a unique number to identify
 *	a successful (?) change.  Do it
 *	through a separate transaction to
 *	to avoid tying down a database hotspot.
 *      called from STUFF_change and STUFF_loop_change
 *      when module is returned to db
 **************************************/
SLONG	*NEXT_TR, next_no;

NEXT_TR = NULL;

START_TRANSACTION NEXT_TR CONSISTENCY READ_WRITE 
    RESERVING CHANGE_NOS FOR WRITE;

FOR (TRANSACTION_HANDLE NEXT_TR) C IN CHANGE_NOS

	next_no = C.CHANGE_NO;
	MODIFY C USING
		C.CHANGE_NO = C.CHANGE_NO + 1;
	END_MODIFY;

END_FOR;

COMMIT NEXT_TR;

return next_no;
}

#ifdef _ANSI_PROTOTYPES_
static int get_derivatives (
    D_STCK	d_stack,
    USHORT	d_count)    
#else
static int get_derivatives (d_stack, d_count)
    D_STCK	d_stack;
    USHORT	d_count;    
#endif
{
/**************************************
 *
 *	g e t _ d e r i v a t i v e s
 *
 **************************************
 *
 * Functional description
 *	Load derived files back into source
 *	records when they have been updated.
 *
  **************************************/
TEXT	filename [80];

while (d_count--)
    { 
    sprintf (filename, "source/%s/%s", d_stack->comp, d_stack->module);
    STUFF_upcase (d_stack->comp, d_stack->comp);
    STUFF_upcase (d_stack->module, d_stack->module);
    STUFF_update_source (d_stack->module, d_stack->comp, filename);
    d_stack = d_stack->next;
    }
}

#ifdef _ANSI_PROTOTYPES_
static int get_description (
    TEXT	*filename)
#else
static get_description (filename)
    TEXT	*filename;
#endif
{
/**************************************
 *
 *	g e t _ d e s c r i p t i o n
 *
 **************************************
 *
 * Functional description 
 *	Get a complete description of a
 *	change into a semi-temporary file.
 *	Generate a unqiue file name for it
 *	and leave it to the caller to unlink
 *	the file.
 *
 **************************************/
  
strcpy (filename, TEMP_FILE);
mktemp (filename);

printf ("Enter a complete description of the changes\n");
gds__edit (filename, TRUE);
}

#ifdef _ANSI_PROTOTYPES_
static int get_diffs (
    TEXT    *comp,
    TEXT    *module,
    TEXT    *oldfile,
    TEXT    *diff_file)    
#else
static int get_diffs (comp, module, oldfile, diff_file)
    TEXT    *comp, *module, *oldfile, *diff_file;    
#endif
{
/**************************************
 *
 *	g e t _ d i f f s
 *
 **************************************
 *
 * Functional description 
 * 	Run diffs on a dumped old file and
 *	the file being put back.
 *
 **************************************/
TEXT	newfile [50];

strcpy (diff_file, DIF_FILE);
mktemp (diff_file);
strcpy (newfile, OLDFILE);
mktemp (newfile); 

if (!STUFF_written_out (comp, module, newfile, FALSE)) 
    {
    unlink (newfile);
    printf ("Diffs failed, file open failure\n");
    return FALSE;
    }              

printf ("Doing DIFFS\n");

#ifdef UNIX
{
/* For Unix platforms we can assume we have standard diff available.
 * So we use standard diff instead of isc_diff, and throw in the -w
 * switch so whitespace differences are ignored.
 */
TEXT	cmd_buffer [200];
sprintf (cmd_buffer, "%s %s %s > %s", "diff -w", oldfile, newfile, diff_file);
EXEC_run (cmd_buffer, NULL, NULL, NULL, FALSE);
}
#else	/* UNIX */
#ifdef VMS
{
/* For VMS, we use DIFFERENCES, which is similar but not identical to
 * Unix diff.  jgalt 3/12/96
 */
TEXT	cmd_buffer [250];
sprintf (cmd_buffer, "%s %s %s /OUTPUT=%s",
	 "DIFFERENCES /NUMBER /IGNORE=(SPACING,BLANK_LINES,TRAILING_SPACES)",
	 oldfile, newfile, diff_file);
EXEC_run (cmd_buffer, NULL, NULL, NULL, FALSE);
}
#else
EXEC_run (LIKENESS, oldfile, newfile, diff_file, FALSE);
#endif
#endif	/* UNIX */

unlink (oldfile);
unlink (newfile);

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
static int get_last_date (
    TEXT	*last_date)
#else
static int get_last_date (last_date)
    TEXT	*last_date;
#endif
{
/**************************************
 *
 *	g e t _ l a s t _ d a t e
 *
 **************************************
 *
 * Functional description
 *
 *	look for a file in directory with path
 *      specified by source/component and name
 *      generated using component.  if its there
 *      copy the contents into share_since_date
 **************************************/
FILE 	*date_file;
TEXT	filename [128], temp [64];
SLONG	clock;
struct tm	times;

clock = time (NULL);
times = *localtime (&clock);

STUFF_lowcase (component, temp);

if (NOT_NULL (pathname))
    sprintf (filename, "%s%s/date.save", pathname, temp);
else
    sprintf (filename, DATE_FILE, temp);

if ((date_file = fopen (filename, "r")) == NULL)
    {
    fprintf (stderr, "%s isn't there.", filename);
    return FALSE;
    }
fscanf (date_file, "%s", last_date);
fclose (date_file);

/* store today's date for reference */

date_file = fopen (filename, "w");
fprintf (date_file, "%d/%d/%d", times.tm_mon + 1, times.tm_mday, times.tm_year);
fclose (date_file);

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
static int header_updatable (
   TEXT    *module,
   TEXT    *comp) 
#else
static header_updatable (module, comp)
   TEXT    *module, *comp; 
#endif
{
/**************************************
 *
 *	h e a d e r _ u p d a t a b l e
 *
 **************************************
 *
 * Functional description
 *
 **************************************/
TEXT	filetype [6];
USHORT	count;

count = 0;

FOR S IN SOURCES WITH
    S.MODULE EQ module AND
    S.COMPONENT EQ comp AND
    S.FILE_TYPE NOT MISSING

    count++;
    strncpy (filetype, S.FILE_TYPE, 5);

END_FOR;

if (!count)
    return FALSE;

filetype [5] = 0;

return updatable_types (filetype) ? TRUE : FALSE;
}

#ifdef _ANSI_PROTOTYPES_
static int init_derivative(
    TEXT    *comp,
    TEXT    *module,
    TEXT    *derivative)
#else
static int init_derivative(comp, module, derivative)
    TEXT    *comp, *module, *derivative;
#endif
{
/**************************************
 *
 *	i n i t _ d e r i v a t i v e
 *
 **************************************
 *
 * Functional description
 *  	Store the key fields of a source record for
 *      a derived file 	
 *
 **************************************/

STUFF_upcase (derivative, derivative);

STORE S IN SOURCES USING 
    strncpy (S.DERIVED_FROM, module, 39);
    strncpy (S.COMPONENT, comp, 19);
    strncpy (S.MODULE, derivative, 39);
END_STORE
    ON_ERROR
	{
	STUFF_error_report (comp, module, 0, gds__status);
	return (FALSE);
	}
    END_ERROR;

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
static int list_switches (void)
#else
static list_switches ()
#endif
{
/**************************************
 *
 *	l i s t _ s w i t c h e s
 *
 **************************************
 *
 * Functional description
 *	Loop through table of switches and print comments.
 *
 **************************************/
TEXT	**caption;

printf ("Switches are:\n");

for (caption = switches; *caption; caption++)
    printf ("%s\n", *caption);
}


#ifdef _ANSI_PROTOTYPES_
static int mail_message (
   TEXT		*message,
   TEXT		*user)
#else
static mail_message (message, user)
   TEXT		*message, *user;
#endif
{
/**************************************
 *
 *	m a i l _ m e s s a g e
 *
 **************************************
 *
 * Functional description
 *	Deliver a mail message to the specified user.
 *         
 **************************************/
TEXT	mail_command [256], mailfile [50];
FILE	*mail;

/* create the temporary mail file and stuff the message in it */

strcpy (mailfile, MAIL_FILE);
mktemp (mailfile); 
if (!(mail = fopen (mailfile, "w")))
    {
    fprintf (stderr, "Unable to open mailfile %s for writing.\n", mailfile);
    return;
    }
fputs (message, mail);
fclose (mail);

/* send the mail message */

sprintf (mail_command, "%s -s 'Notification from MARION' %s < %s",
     MAIL_PROGRAM, user, mailfile);

/* Note: don't lowercase the command as mktemp may use
   uppercase characters in the temp filename */
EXEC_run (mail_command, NULL, NULL, NULL, FALSE);

unlink (mailfile);
}


#ifdef _ANSI_PROTOTYPES_
static UCHAR *mpexl_translate_output (
    UCHAR	*input,
    UCHAR	**output_ptr)
#else
static UCHAR *mpexl_translate_output (input, output_ptr)
    UCHAR	*input;
    UCHAR	**output_ptr;
#endif
{
/**************************************
 *
 *	m p e x l _ t r a n s l a t e _ o u t p u t 
 *
 **************************************
 *
 * Functional description         
 *	MPE/XL-specific translation of include directives
 *	of the form:  #include "source/fac/module.h".
 *
 **************************************/
BASED_ON SOURCES.COMPONENT	component;
BASED_ON SOURCES.MODULE		module, compressed;
UCHAR		*output, *cp, *mp;

output = *output_ptr;
cp = (UCHAR*) component;
mp = (UCHAR*) module;

/* In summary: Skip to quote, skip to first slash, copy component,
   copy module, compress the file name, copy the compressed
   file name, return. */
   
while (*input != '\"')
    *output++ = *input++;
*output++ = *input++;

while (*input != '/')
    input++;
input++;

while (*input != '/')
    *cp++ = *input++;
*cp = '\0';
*input++;

while (*input != '\"')
    *mp++ = *input++;
*mp = '\0';

MPEXL_compress_name (component, module, compressed);

strcpy (output, compressed);
*output_ptr = output + strlen (compressed);

return input;
}

#ifdef _ANSI_PROTOTYPES_
static int stack_derivatives (
    TEXT 	*module,
    TEXT 	*comp,
    D_STCK	*current)
#else
static int stack_derivatives (module, comp, current)
    TEXT 	*module, *comp;
    D_STCK	*current;
#endif
{
/**************************************
 *
 *	s t a c k _ d e r i v a t i v e s
 *
 **************************************
 *
 * Functional description
 *	create a linked list of derived files 
 *	for return to marion after a make on the component
 *	currently being updated  if this is the right os
 *
 **************************************/
D_STCK	next;
USHORT	count;

count = 0;

FOR S IN SOURCES WITH
    S.COMPONENT EQ comp AND
    S.DERIVED_FROM EQ module

    STUFF_lowcase (S.MODULE, (*current)->module);
    STUFF_lowcase (S.COMPONENT, (*current)->comp);
    ++count;
    (*current)->next = (D_STCK) GDS_ALLOC ((SLONG) sizeof (struct d_stck));
    *current = (*current)->next; 

END_FOR;

return count;
}

#ifdef _ANSI_PROTOTYPES_
static int strip_header (
    FILE	*infp)
#else
static strip_header (infp)
    FILE	*infp;
#endif
{
/**************************************
 *
 *	s t r i p _ h e a d e r
 *
 **************************************
 *
 * Functional description
 *	Look a the incoming module, and strip off the
 *	header we find on that.
 *
 **************************************/
SLONG	offset;
TEXT	buffer [256];
SCHAR	c;

offset = ftell (infp);

/* now get rid of the old history section */

fgets (buffer, sizeof (buffer), infp);

if (compare (HEAD1, buffer))
    {
    while (!(compare (TAIL, buffer)))
        if (!(fgets (buffer, sizeof (buffer), infp)))
	    {
	    printf ("Horrors, I just ate your whole module looking for the end of the history comment!\n");
	    exit (1);
	    }
    while ((c = getc (infp)) != EOF && (c == '\f' || c == '\n'))
	;
    ungetc (c, infp);
    }
else
    fseek (infp, offset, 0);
}

#ifdef _ANSI_PROTOTYPES_
static int translate_in (
    TEXT	*input,
    TEXT	*output,
    USHORT       *oscode)
#else
static translate_in (input, output, oscode)
    TEXT	*input;
    TEXT	*output;
    USHORT       *oscode;
#endif
{
/**************************************
 *
 *	t r a n s l a t e _ i n 
 *
 **************************************
 *
 * Functional description
 *	Translate a line of source.
 *
 **************************************/
TEXT	*p, *tail, *s, *out, *s1, c;
S	*ptr;
USHORT   i, result;

/* If this is a System V based port, do any qualified name fixups.  If we find
   a gds-qualified symbol on the line, assume that the line does NOT contain
   an include statement. */

if (op_sys_code == OS_UNIX_NO_DOLLAR ||
    op_sys_code == OS_PC ||
    op_sys_code == OS_WIN_NT ||
    op_sys_code == OS_MPEXL)
    {
    out = output;
    s1 = NULL;
    result = FALSE;
    p = input;
    while (*out++ = c = *p++)
	{
	if (s1 && c != *s1++)
	    {
	    if (c == '_' && !s1 [-1])
		{
		out [-1] = '$';
		result = TRUE;
		}
	    s1 = NULL;
	    }
	if (!s1)
	    s1 = vector [(unsigned int) (unsigned char) c];
	}
    if (result)
	return TRUE;
    }

/* Look for one of our strings */

for (ptr = in_strings, i = 0; ptr->s_string; ptr++)
    {
    i++;
    if (tail = compare (ptr->s_string, input))
	break;
    }

if (!ptr->s_string)
    return FALSE;

/* Copy in replacement */

for (p = ptr->s_replacement; *p; )
    *output++ = *p++;

/* copy file path, reversing slashes if necessary */

for (; *tail; tail++)
    *output++ = (*tail == '\\' && tail [1] != 0 && p[1] != '\n') ? '/' : *tail;

*output = 0;

return TRUE;
} 

#ifdef _ANSI_PROTOTYPES_
static int translate_out (
    UCHAR	*input,
    UCHAR	*output)
#else
static translate_out (input, output)
    UCHAR	*input;
    UCHAR	*output;
#endif
{
/**************************************
 *
 *	t r a n s l a t e _ o u t 
 *
 **************************************
 *
 * Functional description
 *	Translate a line of output.
 *      1/5 make sure all vms lines get used
 *
 **************************************/
UCHAR	c, *p, *tail, *s1, *s2, *out, *end;
SSHORT	result;

/* If this is a System V based port, do any qualified name fixups.  If we find
   a gds-qualified symbol on the line, assume that the line does NOT contain
   an include statement. */

if (op_sys_code == OS_UNIX_NO_DOLLAR ||
    op_sys_code == OS_PC ||
    op_sys_code == OS_WIN_NT ||
    op_sys_code == OS_MPEXL)
    {
    out = output;
    s1 = NULL;
    result = FALSE;
    p = input;
    while (*out++ = c = *p++)
	{
	if (s1 && c != *s1++)
	    {
	    if (c == '$' && !s1 [-1])
		{
		out [-1] = '_';
		result = TRUE;
		}
	    s1 = NULL;
	    }
	if (!s1)
	    s1 = vector [(unsigned int) (unsigned char) c];
	}
    if (result)
	return TRUE;
    }

/* Check for include files to be zapped */

if (*input != '#' || !(s1 = out_strings1 [op_sys_code].s_string))
    return FALSE;

s2 = out_strings2 [op_sys_code].s_string;

/* Look for one of our strings */

if (tail = compare (s1, input)) 
    {
    if (op_sys_code == OS_MPEXL)
	tail = mpexl_translate_output (input, &output);
    else
        for (p = out_strings1 [op_sys_code].s_replacement; *p;)
	     *output++ = *p++;
    }
else if (s2 && (tail = compare (s2, input)))
    for (p = out_strings2 [op_sys_code].s_replacement; *p; )
	*output++ = *p++;
else
    return FALSE;

#ifdef PC_PLATFORM

/* do some fancy footwork to compress pathnames to eight characters max */

while (*tail != '.')
    *output++ = *tail++;
for (end = tail + 8; *tail && *tail != '.'; tail++)
    {
    if (*tail == '/' || *tail == '\\') 
	end = tail + 9;
    if (tail < end)
	*output++ = *tail;
    }
#endif

for (; *tail; tail++)
    *output++ = *tail;

*output = 0;

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
static int updatable_types (
    TEXT	*filetype)
#else
static updatable_types (filetype)
    TEXT	*filetype;
#endif
{
/**************************************
 *
 *	u p d a t a b l e _ t y p e s
 *
 **************************************
 *
 * Functional description
 *   Decide which files deserve to have a history
 *   header generated.  Currently only:
 *   .C .E .CPP .H and .Y suffexes.
 *
 **************************************/
TEXT	*f;

for (f = filetype; *f && *f != ' '; f++)
    ;
*f = 0;

if (!strcmp (filetype, "E") ||
    !strcmp (filetype, "C") ||
    !strcmp (filetype, "CPP") ||
    !strcmp (filetype, "H") ||
    !strcmp (filetype, "Y"))
    return TRUE;

return FALSE;
}

#ifdef _ANSI_PROTOTYPES_
static int construct_header (
    TEXT	*comp,
    TEXT	*module,
    BSTREAM	*outb,
    FILE	*outf)
#else
static construct_header (comp, module, outb, outf)
    TEXT	*comp, *module;
    BSTREAM	*outb;
    FILE	*outf;
#endif
{
/**************************************
 *
 *	c o n s t r u c t _ h e a d e r 
 *
 **************************************
 *
 * Functional description
 *	THis actually creates a whole new header each time.
 *	as we are given to cloning modules and marions.
 *
 *	The order of battle is a little baroque.  First we
 *	construct the new header, and stuff that in to marion.
 *
 **************************************/
TEXT	line [256], date [20];
TEXT	*b;
USHORT   first;
SLONG 	clock;
struct tm	d;

/* pick up some interesting information */

clock = time (NULL);
d = *localtime (&clock);
sprintf (date, "%d-%s-%d", d.tm_mday, months [d.tm_mon], 1900 + d.tm_year);

/* write the initial comment block */

if (outb)
    for (b = HEAD1; *b; b++)
	putb (*b, outb);
else
    fputs (HEAD1, outf);

FOR B IN BASE_LEVEL
    sprintf (line, HEAD2, comp, module, VERSION, B.VERSION, date);
END_FOR;

if (outb)
    for (b = line; *b; b++)
	putb (*b, outb);
else
    fputs (line, outf);

if (outb)
    for (b = HEAD3; *b; b++)
	putb (*b, outb);
else
    fputs (HEAD3, outf);

/* write the actual history */ 

first = outb ? TRUE : FALSE;

FOR FIRST 15 H IN HISTORY WITH
    H.COMPONENT EQ comp AND
    H.MODULE EQ module
    SORTED BY DESC H.CHANGE_NO
    if (first) 
	{
	first = FALSE;
        sprintf (line, TAG, H.CHANGE_NO, H.CHANGED_BY, date, H.CHANGE_TAG);
	}
    else
        sprintf (line, TAG, H.CHANGE_NO, H.CHANGED_BY, H.RETURN_DATE.CHAR[11], H.CHANGE_TAG); 

    if (outb)
	for (b = line; *b; b++)
            putb (*b, outb);
    else
	fputs (line, outf);
END_FOR;

if (outb)
    for (b = COMMENT_END; *b; b++)
	putb (*b, outb);
else
    fputs (COMMENT_END, outf);
}

#ifdef _ANSI_PROTOTYPES_
static int update_history (
    TEXT	*module,
    TEXT	*comp,
    TEXT	*desc_file,
    TEXT	*diff_file)
#else
static int update_history (module, comp, desc_file, diff_file)
    TEXT	*module, *comp;
    TEXT	*desc_file, *diff_file;
#endif
{
/**************************************
 *
 *	 u p d a t e _ h i s t o r y
 *
 **************************************
 *
 * Functional description
 *	Update the history record for a module
 *	that is being checked back in. Note that
 *	the history should be updated AFTER the
 *	source module is safely back in the database
 *	to avoid annoying the trigger trolls.
 *
 *	1/89 added diffs to history record
 *      2/89 take get_summary out so we can put correct summary
 *           into source header
 *      This seems like a good place to check that
 *      the checkin directory = the checkout directory
 *      and to query if its not
 *
 **************************************/
SLONG 	clock;
struct tm	d;

clock = time (NULL);
d = *localtime (&clock);

FOR H IN SMM.HISTORY WITH
    H.MODULE EQ module AND
    H.COMPONENT EQ comp AND
    H.RETURN_DATE MISSING

    MODIFY H USING
	BLOB_load (&H.CHANGE_WHAT, SMM, gds__trans, desc_file);
	BLOB_load (&H.DIFFS, SMM, gds__trans, diff_file);
	gds__encode_date (&d, &H.RETURN_DATE);
    END_MODIFY
    ON_ERROR
	{
	STUFF_error_report (comp, module, 0, gds__status);
	return FALSE;
	}
    END_ERROR;

END_FOR;

return TRUE;
}

#ifdef _ANSI_PROTOTYPES_
static int update_summary (
    TEXT	*comp,
    TEXT	*module,
    TEXT	*summary,
    SLONG	change_num)
#else
static int update_summary (comp, module, summary, change_num)
    TEXT	*comp, *module, *summary;
    SLONG	change_num;
#endif
{
/**************************************
 *
 *	u p d a t e _ s u m m a r y
 *
 **************************************
 *
 * Functional description
 *	allow user to update summary on return of
 *      module to database
 *      Since this happens early in the checkin process
 *      it seems like a good place to put the compulsive
 *      questioning
*
 **************************************/
TEXT	thisdir [128], thishost [20];
TEXT	answer [5];

FOR H IN HISTORY WITH
    H.COMPONENT EQ comp AND
    H.MODULE EQ module AND
    H.RETURN_DATE MISSING

    if (EXEC_get_host_dir (thishost, thisdir))
	{
	if (strcmp (thishost, H.HOST) ||
	    strcmp (thisdir, H.WHERE))
	    {
	    printf ("You checked %s out from %s %s.\n",module, H.HOST, H.WHERE);
            printf ("Do you REALLY want to check it in from %s, %s", thishost, thisdir);
            STUFF_get_string ("?",answer, sizeof (answer)); 
            if (*answer == 'y'  || *answer == 'Y')
		printf ("Ok, just checking...\n");
            else
		return FALSE;
	    }
	}

        MODIFY H USING
	    strcpy (summary, H.CHANGE_TAG);
	    while (!STUFF_get_summary (summary, 80))
		if (cancel_edit())
		    return FALSE;
	    strcpy (H.CHANGE_TAG, summary);
	    H.CHANGE_NO = change_num;
        END_MODIFY

END_FOR;

return TRUE;
}
